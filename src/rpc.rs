use std::{sync::{Arc}, net::{IpAddr, Ipv6Addr}};
use tokio::sync::Mutex;

use tarpc::{context::Context, tokio_serde::formats::Json, server::incoming::Incoming};
use tracing::info;

use crate::{structures::{Sha256Bytes, Block}, db::{RocksDB}, fork_choice::ForkChoice};
use tarpc::{server::{self, Channel}, client::Config, context};
use futures::{future, prelude::*};

// todo: change to use bytemuck Codec (not json/serde)
#[tarpc::service]
pub trait RPC { 
    async fn get_block(hash: Sha256Bytes) -> Option<Block>;
    async fn get_head() -> Option<Sha256Bytes>;
}

#[derive(Clone)]
struct Server { 
    db: Arc<RocksDB>,
    fork_choice: Arc<Mutex<ForkChoice>>,
}

#[tarpc::server]
impl RPC for Server { 
    async fn get_block(self, _: Context, block_hash: Sha256Bytes) -> Option<Block> { 
        self.db.get(block_hash).map(Some).unwrap_or(None)
    }

    async fn get_head(self, _: Context) -> Option<Sha256Bytes> { 
        self.fork_choice.lock().await.get_head() // safe to unwrap here
    }
}

pub async fn rpc(
    db: Arc<RocksDB>,
    fork_choice: Arc<Mutex<ForkChoice>>,
    port: u16,
) -> anyhow::Result<()> { 
    let _server = Server { 
        db,
        fork_choice,
    };

    let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), port);

    // JSON transport is provided by the json_transport tarpc module. It makes it easy
    // to start up a serde-powered json serialization strategy over TCP.
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    info!("Listening on {}", listener.local_addr());

    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = _server.clone();
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;

    Ok(())
}


#[cfg(test)] 
mod tests { 
    use std::sync::Arc;
    use tarpc::{server::{self, Channel}, client::Config, context};
    use crate::{get_tmp_ledger_path_auto_delete, db::RocksDB};
    use rocksdb::DB;

    use super::*;

    #[tokio::test]
    async fn test_block_lookup() -> anyhow::Result<()> { 
        let path = get_tmp_ledger_path_auto_delete!();
        let db = DB::open_default(path).unwrap();
        let db = Arc::new(RocksDB { db });

        let fc = db.insert_genesis().unwrap();
        let fc = Arc::new(Mutex::new(fc));

        let _server = Server { 
            db: db.clone(),
            fork_choice: fc.clone()
        };

        let genesis = Block::genesis(); 
        // no db insertion

        let (client_transport, server_transport) = tarpc::transport::channel::unbounded();
        let server = server::BaseChannel::with_defaults(server_transport);
        tokio::spawn({
            server.execute(_server.serve())
        });

        let client = RPCClient::new(Config::default(), client_transport).spawn();

        let block = client.get_block(context::current(), genesis.header.block_hash).await?;
        assert!(block.is_none());

        // block is now in db (should be rpc servable)
        db.put(&genesis)?;

        let block = client.get_block(context::current(), genesis.header.block_hash).await?;
        assert!(block.is_some());
        let rpc_block = block.unwrap(); 
        assert_eq!(rpc_block.header.block_hash, genesis.header.block_hash);

        Ok(())
    }

}